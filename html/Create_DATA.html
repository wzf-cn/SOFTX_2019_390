
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>PLCP DATA</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-08-23"><meta name="DC.source" content="Create_DATA.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>PLCP DATA</h1><!--introduction--><p>Creation of the DATA field of a PLCP package.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1"><b>Syntax</b></a></li><li><a href="#2"><b>Description</b></a></li><li><a href="#4"><b>Examples</b></a></li></ul></div><h2 id="1"><b>Syntax</b></h2><p>DATA = Create_DATA(PSDU, M, r)</p><h2 id="2"><b>Description</b></h2><p>The function Create_DATA(PSDU, M, r) returns the DATA field of a PLCP packet. It generates the SERVICE (16 bits) and Tail (6 bits) fields. Also generates the padding bits and concatenate all of them with the payload of the packet according to the IEEE 802.11-2012 standard.</p><p><img vspace="5" hspace="5" src="Data_field.PNG" alt=""> </p><p><b>Input arguments</b></p><div><ul><li>PSDU</li></ul></div><p>Data bits vector of a single package.</p><div><ul><li>M</li></ul></div><p>Modulation scheme to be used.</p><div><ul><li>r</li></ul></div><p>Coding rate.</p><p><b>Output arguments</b></p><div><ul><li>DATA</li></ul></div><p>DATA field in  time domain of the PLCP PDU.</p><h2 id="4"><b>Examples</b></h2><p>The function Create_DATA(PSDU, M, r) is called.</p><pre class="codeinput"><span class="keyword">function</span> DATA = Create_DATA(PSDU, M, r)
</pre><p>Creation of the field DATA of a single package. The number of coded bits per subcarrier, the number of coded bits per symbol and the number of data bits per symbol is obtained according to the IEEE 802.11 standard.</p><pre class="codeinput">    m = log2(M);
    NBPSC = m;
    NCBPS = NBPSC * 48;
    NDBPS = NCBPS * r;
</pre><p>The service field is composed of 16 bits and the tail field of 6 bits. The vectors are generated with the number of symbols to be used and the padded bits are calculated.</p><pre class="codeinput">    SERVICE = zeros(1,16);
    TAIL = zeros(1,6);
    NSYM =  ceil((length(PSDU)+length(SERVICE)+length(TAIL))/NDBPS);     <span class="comment">%Number of symbols to generate</span>
    NBITS = NSYM * NDBPS;                                                <span class="comment">%Total number of bits (after padding)</span>
    NPAD = NBITS - ( length(PSDU) + length(SERVICE) + length(TAIL) );    <span class="comment">%Number of padding bits necessary</span>
    PAD = zeros(1,NPAD);
</pre><p>DATA field construcction according to the IEEE 802.11-2012 standard.</p><pre class="codeinput">    ODATA = [SERVICE PSDU TAIL PAD];
</pre><p>To map a symbol, the following steps are followed:</p><p><b>Scrambling</b></p><p>The scrambling is done with the PDU and an Initial state  = [1 0 1 1 1 0 1] according to the IEEE 802.11 standard.</p><pre class="codeinput">    SDATA = scrambleString(ODATA, [1 0 1 1 1 0 1]);
</pre><p>The TAIL bits are set to 0 after the scramble because they do not participate in the scrambling process according to the IEEE 802.11 standard.</p><pre class="codeinput">	SDATA( length(SERVICE) + length(PSDU) + 1 : length(SERVICE) + length(PSDU) + length(TAIL)) = 0;
</pre><p><b>Coding</b></p><p>The coding is done with a coding rate r.</p><pre class="codeinput">    CDATA = Encode_String(SDATA, r);
</pre><p><b>Interleaving</b></p><p>The interleaving process is based on the number of coded bits per symbol.</p><pre class="codeinput">    IDATA = Interleaver_string(CDATA, NCBPS);
</pre><p><b>Modulation</b></p><p>The modulation process is carried out with the M modulation scheme.</p><pre class="codeinput">    MDATA = modulation_string(IDATA, M);
</pre><p><b>OFDM Modulation</b></p><p>The construction of OFDM symbols arrays for all data symbols.</p><pre class="codeinput">	DATA = modulation_OFDM(MDATA);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p><b>See also</b></p><p><a href="scrambleString.html">scrambleString</a></p><p><a href="Encode_String.html">Encode String</a></p><p><a href="Interleaver_string.html">Interleaver string</a></p><p><a href="modulation_string.html">modulation_string</a></p><p><a href="modulation_OFDM.html">modulation_OFDM</a></p><p><a href="txOFDM.html">OFDM package transmission</a></p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% PLCP DATA
    % Creation of the DATA field of a PLCP package.
    %% *Syntax*
    % DATA = Create_DATA(PSDU, M, r)
    %% *Description*
    % The function Create_DATA(PSDU, M, r) returns the DATA field of a PLCP
    % packet.
    % It generates the SERVICE (16 bits) and Tail (6 bits) fields. Also 
    % generates the padding bits and concatenate all of them with
    % the payload of the packet according to the IEEE 802.11-2012 standard.
   %%
    % 
    % <<Data_field.PNG>>
    %
    % *Input arguments*
    %
    % * PSDU
    %
    % Data bits vector of a single package.
    %
    % * M
    %
    % Modulation scheme to be used.
    %
    % * r
    %
    % Coding rate.
    %
    % *Output arguments*
    %
    % * DATA
    %
    % DATA field in  time domain of the PLCP PDU.

    %% *Examples*
    % The function Create_DATA(PSDU, M, r) is called.
function DATA = Create_DATA(PSDU, M, r)
%%
    % Creation of the field DATA of a single package.
    % The number of coded bits per subcarrier, the number of coded 
    % bits per symbol and the number of data bits per symbol is obtained 
    % according to the IEEE 802.11 standard.       
    
    m = log2(M); 
    NBPSC = m;                              
    NCBPS = NBPSC * 48;                   	
    NDBPS = NCBPS * r;                      
    
%% 
    % The service field is composed of 16 bits and the tail field of 6
    % bits. The vectors are generated with the number of symbols to be
    % used and the padded bits are calculated.
    SERVICE = zeros(1,16);                 
    TAIL = zeros(1,6);                      
    NSYM =  ceil((length(PSDU)+length(SERVICE)+length(TAIL))/NDBPS);     %Number of symbols to generate
    NBITS = NSYM * NDBPS;                                                %Total number of bits (after padding)
    NPAD = NBITS - ( length(PSDU) + length(SERVICE) + length(TAIL) );    %Number of padding bits necessary
    PAD = zeros(1,NPAD);
 %%
    % DATA field construcction according to the IEEE 802.11-2012 standard. 
    ODATA = [SERVICE PSDU TAIL PAD];                       
 %%    
    % To map a symbol, the following steps are followed:
%%
    % *Scrambling*
    %
    % The scrambling is done with the PDU and an Initial state  = [1 0 1 1 1 0 1] 
    % according to the IEEE 802.11 standard.   
    SDATA = scrambleString(ODATA, [1 0 1 1 1 0 1]);              
%%
    % The TAIL bits are set to 0 after the scramble because they
    % do not participate in the scrambling process according to the IEEE
    % 802.11 standard.
	SDATA( length(SERVICE) + length(PSDU) + 1 : length(SERVICE) + length(PSDU) + length(TAIL)) = 0;       
%%
    % *Coding*
    %
    % The coding is done with a coding rate r.
    CDATA = Encode_String(SDATA, r);                 
%%
    % *Interleaving*
    %
    % The interleaving process is based on the number of coded bits per
    % symbol.
    IDATA = Interleaver_string(CDATA, NCBPS);           
%%
    % *Modulation*
    %
    % The modulation process is carried out with the M modulation scheme.    
    MDATA = modulation_string(IDATA, M);                       
%%
    % *OFDM Modulation*
    %
    % The construction of OFDM symbols arrays for all data symbols.
	DATA = modulation_OFDM(MDATA);             
end

%%
    % *See also*
    %
    % <scrambleString.html scrambleString> 
    %
    % <Encode_String.html Encode String>
    %
    % <Interleaver_string.html Interleaver string>
    %
    % <modulation_string.html modulation_string>
    %
    % <modulation_OFDM.html modulation_OFDM>
    %
    % <txOFDM.html OFDM package transmission>
##### SOURCE END #####
--></body></html>